use crate::api::Message;
use crate::config::AppConfig;
use crate::logger::{Logger, SessionMetrics};
use crate::python_exec::CodeExecutor;
use serde::Serialize;
use std::sync::Arc;
use tokio::sync::{broadcast, RwLock};

/// Events streamed to WebSocket clients for real-time dashboard updates.
#[derive(Clone, Debug, Serialize)]
#[serde(tag = "type")]
pub enum ExecutionEvent {
    /// A line of stdout or stderr output from a running script.
    LogLine {
        timestamp: String,
        stream: String,
        content: String,
    },
    /// A script execution has started.
    ExecutionStarted { script_path: String },
    /// A script execution has completed.
    ExecutionCompleted {
        success: bool,
        exit_code: Option<i32>,
    },
    /// New code was generated by the LLM.
    CodeGenerated { code: String, script_path: String },
}

/// A generated script entry for the history view.
#[derive(Clone, Debug, Serialize)]
pub struct ScriptEntry {
    pub filename: String,
    pub path: String,
    pub timestamp: String,
}

/// Shared application state accessible by both the REPL and the web dashboard.
///
/// Wrapped in `Arc` and passed to both the Axum server and the REPL loop.
pub struct DashboardState {
    pub config: AppConfig,
    pub metrics: RwLock<SessionMetrics>,
    pub conversation_history: RwLock<Vec<Message>>,
    pub last_generated_code: RwLock<String>,
    pub event_tx: broadcast::Sender<ExecutionEvent>,
    pub executor: CodeExecutor,
    pub logger: Logger,
}

impl DashboardState {
    /// Create a new shared state with a broadcast channel for execution events.
    pub fn new(
        config: AppConfig,
        executor: CodeExecutor,
        logger: Logger,
    ) -> Arc<Self> {
        let (event_tx, _) = broadcast::channel(256);
        Arc::new(Self {
            config,
            metrics: RwLock::new(SessionMetrics::new()),
            conversation_history: RwLock::new(Vec::new()),
            last_generated_code: RwLock::new(String::new()),
            event_tx,
            executor,
            logger,
        })
    }

    /// Broadcast an execution event to all connected WebSocket clients.
    /// Silently ignores errors if there are no active receivers.
    pub fn broadcast(&self, event: ExecutionEvent) {
        let _ = self.event_tx.send(event);
    }
}
