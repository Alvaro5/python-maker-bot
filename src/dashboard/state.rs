use crate::api::Message;
use crate::config::AppConfig;
use crate::logger::{Logger, SessionMetrics};
use crate::python_exec::CodeExecutor;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{broadcast, Mutex, RwLock};

// ── Events streamed to WebSocket clients ─────────────────────────────

/// Events streamed to WebSocket clients for real-time dashboard updates.
#[derive(Clone, Debug, Serialize)]
#[serde(tag = "type")]
pub enum ExecutionEvent {
    /// A line of stdout or stderr output from a running script.
    LogLine {
        timestamp: String,
        stream: String,
        content: String,
    },
    /// A script execution has started.
    ExecutionStarted { script_path: String },
    /// A script execution has completed.
    ExecutionCompleted {
        success: bool,
        exit_code: Option<i32>,
    },
    /// New code was generated by the LLM.
    CodeGenerated { code: String, script_path: String },
    /// Lint check result.
    LintCompleted {
        passed: bool,
        diagnostics: String,
    },
    /// Security scan result.
    SecurityCompleted {
        passed: bool,
        diagnostics: String,
    },
    /// A running script was killed by the user.
    ExecutionKilled,
    /// A running script is waiting for user input (stdin).
    WaitingForInput {
        prompt: String,
    },
}

// ── Script history entry ─────────────────────────────────────────────

/// A generated script entry for the history view.
#[derive(Clone, Debug, Serialize)]
pub struct ScriptEntry {
    pub filename: String,
    pub path: String,
    pub timestamp: String,
}

// ── Chat sessions ────────────────────────────────────────────────────

/// A single chat session with its own conversation history and generated code.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ChatSession {
    pub id: String,
    pub name: String,
    pub messages: Vec<Message>,
    pub last_generated_code: String,
    pub created_at: String,
}

// ── Runtime settings (mutable subset of AppConfig) ───────────────────

/// Settings that can be changed at runtime from the dashboard UI.
/// Initialized from `AppConfig` at startup.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct RuntimeSettings {
    pub provider: String,
    pub model: String,
    pub api_url: String,
    pub temperature: f32,
    pub use_docker: bool,
    pub use_venv: bool,
    pub use_linting: bool,
    pub use_security_check: bool,
    pub execution_timeout_secs: u64,
    pub auto_install_deps: bool,
    pub max_tokens: u32,
}

impl RuntimeSettings {
    /// Initialize from the static `AppConfig`.
    pub fn from_config(config: &AppConfig) -> Self {
        Self {
            provider: config.provider.clone(),
            model: config.model.clone(),
            api_url: config.api_url.clone(),
            temperature: config.temperature,
            use_docker: config.use_docker,
            use_venv: config.use_venv,
            use_linting: config.use_linting,
            use_security_check: config.use_security_check,
            execution_timeout_secs: config.execution_timeout_secs,
            auto_install_deps: config.auto_install_deps,
            max_tokens: config.max_tokens,
        }
    }

    /// Build an ephemeral `AppConfig` by overlaying these runtime settings
    /// on top of the base config. Used for LLM API calls.
    pub fn to_app_config(&self, base: &AppConfig) -> AppConfig {
        AppConfig {
            provider: self.provider.clone(),
            model: self.model.clone(),
            api_url: self.api_url.clone(),
            temperature: self.temperature,
            use_docker: self.use_docker,
            use_venv: self.use_venv,
            use_linting: self.use_linting,
            use_security_check: self.use_security_check,
            execution_timeout_secs: self.execution_timeout_secs,
            auto_install_deps: self.auto_install_deps,
            max_tokens: self.max_tokens,
            ..base.clone()
        }
    }
}

// ── Shared dashboard state ───────────────────────────────────────────

/// Shared application state accessible by both the REPL and the web dashboard.
///
/// Wrapped in `Arc` and passed to both the Axum server and the REPL loop.
pub struct DashboardState {
    pub config: AppConfig,
    pub metrics: RwLock<SessionMetrics>,
    /// Legacy flat history kept for REPL compatibility / sync.
    pub conversation_history: RwLock<Vec<Message>>,
    /// Legacy flat last-generated-code kept for REPL sync.
    pub last_generated_code: RwLock<String>,
    pub event_tx: broadcast::Sender<ExecutionEvent>,
    pub executor: CodeExecutor,
    pub logger: Logger,
    /// Named chat sessions (keyed by UUID).
    pub sessions: RwLock<HashMap<String, ChatSession>>,
    /// ID of the currently active chat session.
    pub active_session_id: RwLock<String>,
    /// Runtime-mutable settings (provider, model, toggles, etc.).
    pub runtime_settings: RwLock<RuntimeSettings>,
    /// PID of the currently running script process (for kill support).
    pub running_pid: Mutex<Option<u32>>,
    /// Stdin handle of the currently running script process (for interactive input).
    pub running_stdin: Mutex<Option<std::process::ChildStdin>>,
}

impl DashboardState {
    /// Create a new shared state with a broadcast channel for execution events.
    pub fn new(
        config: AppConfig,
        executor: CodeExecutor,
        logger: Logger,
    ) -> Arc<Self> {
        let (event_tx, _) = broadcast::channel(256);
        let runtime_settings = RuntimeSettings::from_config(&config);

        // Create the default session
        let default_session_id = uuid::Uuid::new_v4().to_string();
        let default_session = ChatSession {
            id: default_session_id.clone(),
            name: "New Chat".to_string(),
            messages: Vec::new(),
            last_generated_code: String::new(),
            created_at: chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string(),
        };
        let mut sessions = HashMap::new();
        sessions.insert(default_session_id.clone(), default_session);

        Arc::new(Self {
            config,
            metrics: RwLock::new(SessionMetrics::new()),
            conversation_history: RwLock::new(Vec::new()),
            last_generated_code: RwLock::new(String::new()),
            event_tx,
            executor,
            logger,
            sessions: RwLock::new(sessions),
            active_session_id: RwLock::new(default_session_id),
            runtime_settings: RwLock::new(runtime_settings),
            running_pid: Mutex::new(None),
            running_stdin: Mutex::new(None),
        })
    }

    /// Broadcast an execution event to all connected WebSocket clients.
    /// Silently ignores errors if there are no active receivers.
    pub fn broadcast(&self, event: ExecutionEvent) {
        let _ = self.event_tx.send(event);
    }
}
